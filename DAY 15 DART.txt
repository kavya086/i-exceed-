1.Abstraction
2.Interfaces
3.Mixins




4.ABSTRACT CLASS:

Any class that is set to be an abstract, cannot have its instance (object). The properties of that class can only be accessed only through its daughter class.
In Dart, only classes can be abstract, methods need not be declared as abstract. Any class that inherit the properties of an abstract class must implement all the methods in the abstract class. Abstract class may contain,
1.Abstract methods (methods without implementation)
2.Concrete methods (methods with implementation)
3.Private methods
But, cant have instances, and all its subclasses must implement the abstract methods

EXAMPLE:

abstract class Teacher
{
    void display(String Subject);
    void concrete()
    {
        print("This is a concrete method"); //can be accessed by all the daughter classes ie, their instances
    }
    void _private()
    {
        print("This is a private method that can be accessed only in this library ie, File");
    }
}
class Student1 extends Teacher
{
    display(String sub)
    {
        print("Student 1 is learning $sub");
    }
    _private()
    {
        print("Private method is overriden");
    }
}
class Student2 extends Teacher
{
    display(String sub)
    {
        print("Student 2 is learning $sub");
    }
}
void main()
{
//     Teacher t=Teacher(); -ERROR - Abstract classes cannot have instances.
//     t.display();
    Student1 s1=Student1();
    Student2 s2=Student2();
    s1.display("Dart");
    s2.display("Java");
    s1.concrete();
    s2.concrete();
    s1._private();
    s2._private();
}

OUTPUT:

Student 1 is learning Dart
Student 2 is learning Java
This is a concrete method
This is a concrete method
Private method is overriden
This is a private method that can be accessed only in this library ie, File


INTERFACES:

There is no specific keyword "interface" in dart as in Java.
Instead of using "extends" for a abstract class, use "implements" for a abstract class, then it will become a interface.
The only difference is, abstract classes need not require us to override the concrete methods in it, but any daughter class of an interface must override all the methods of the super class.


EXAMPLE:

abstract class Shape
{
    void name();
    void draw();
    void display()
    {
        print("Welcome");
    }
}
class Circle implements Shape //implemented all 3 methods including concrete
{
    void name()
    {
        print("Name is Circle");
    }
    void draw()
    {
        print("Drawing Circle...");
    }
    void display()
    {
        print("Overriden welcome");
    }
}
void main()
{
    Circle c1=Circle();
    c1.name();
    c1.draw();
    c1.display();
}


OUTPUT:

Name is Circle
Drawing Circle...
Overriden welcome



BOTH extends and implements in same class :




abstract class Shape
{
    void name();
    void draw();
    double area(double quant);
}
abstract class Resizable
{
    void isResizable();
}
class Circle extends Shape implements Resizable
{
    void name()
    {
        print("Circle");
    }
    void draw()
    {
        print("Drawing Circle");
    }
    double area(double radius)
    {
        return 3.14*radius*radius;
    }
    isResizable()
    {
        bool isResizable=true;
    }
}
class Square extends Shape implements Resizable
{
    void name()
    {
        print("Square");
    }
    void draw()
    {
        print("Drawing Square");
    }
    double area(double side)
    {
        return side*side;
    }
      isResizable()
    {
        bool isResizable=true;
    }
}
class canva
{
   void drawCircle(Circle c)
   {
        c.draw();
   }
   void drawSquare(Square s)
   {
        s.draw();
   }
}
void main()
{
    canva cnv=canva();
    Circle circle =Circle();
    Square square =Square();
    cnv.drawCircle(circle);
    cnv.drawSquare(square);
}


OUTPUT:

Drawing Circle
Drawing Square



MIXINS:

Mixin is used to add functionality to a class without extending it.


EXAMPLE:

mixin addMethod
{
    void method()
    {
        print("Mixin method");
    }
}
class classname with addMethod   //Now, the method() is added to class classname.
{
    void classs()
    {
        print("Class method");
    }
}
void main()
{
    classname c=classname();
    c.method(); //method is accessible
}

OUTPUT:

Mixin method


EXAMPLE:

mixin addMethod
{
    void method()
    {
        print("Mixin method");
    }
}
abstract class classname with addMethod   //Now, the method() is added to class classname.
{
    void method();
    void classs()
    {
        print("Class method");
    }
}
class daughterclass extends classname with addMethod
{
  //overrided by using mixin method 
}
void main()
{
    classname c=daughterclass();
    c.method(); //method is accessible
}



EXAMPLE:


abstract class Teacher
{
    void name();
}

mixin Mixin1
{
    void name()
    {
        print("MIXIN1");
    }
}
mixin Mixin2
{
    void name()
    {
        print("MIXIN2");
    }
}

class Student1 extends Teacher with Mixin1,Mixin2 
{
   void display()
   {

   }
}
class Student2 extends Teacher with Mixin2, Mixin1
{
    void display()
    {

    }
}
void main()
{
    Student1 s1=Student1();
    s1.name(); //print Mixin2, recent update
    Student2 s2=Student2();
    s2.name();  //print Mixin1, recent update
}


OUTPUT:

Mixin2
Mixin1

